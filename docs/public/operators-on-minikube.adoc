== Installing Operators on minkube

This guide assumes that you are using link:https://minikube.sigs.k8s.io/docs/[minikube] v1.11.0 or newer.

In this guide, we will discuss installing two Operators on a minikube environment:

. etcd Operator
. Service Binding Operator

=== Prerequisites

You must enable the `olm` addon for your minikube cluster by doing:
[source,sh]
----
$ minikube addons enable olm
----

=== Installing etcd Operator

Operators can be installed in a specific namepsace or across the cluster (that is, for all the namespaces). We will install etcd Operator across the cluster such that if you create a new namespace, the etcd Operator will be automatically available for use.

To install an Operator, we need to make sure that the namespace in which we're installing it has an `OperatorGroup`. Since we want to install etcd Operator across all the namespaces, we will install it in `operators` namespace and `olm` takes care of making it available across all the namespace.

[NOTE]
====
You can't always install an Operator in the `operators` namespace and expect it to be available across all namespaces. The Operator you're trying to installing needs to be designed to be available in this way as well. Certain Operators only support installation in a single namespace.

Discussing this topic is out of scope of this guide so we have stated it as a note.
====

Enabling the `olm` addon will, among other things, create an `OperatorGroup` in the `operators` namepsace. Make sure that it's there:
[source,sh]
----
$ kubectl get og -n operators
NAME               AGE
global-operators   3m37s
----

If you don't see one, create it using below command:
[source,sh]
----
$ kubectl create -f - << EOF
apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: global-operators 
  namespace: operators 
spec:
  targetNamespaces:
  - operators
EOF
----

Now, install the etcd Operator using below command:
[source,sh]
----
$ kubectl create -f - << EOF
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: etcd
  namespace: operators
spec:
  channel: clusterwide-alpha
  name: etcd
  source: operatorhubio-catalog
  sourceNamespace: olm
  startingCSV: etcdoperator.v0.9.4-clusterwide
  installPlanApproval: Automatic
EOF
----

Give it a few seconds before checking the availability of the etcd Operator:
[source,sh]
----
$ odo catalog list services
Operators available in the cluster
NAME                                CRDs
etcdoperator.v0.9.4-clusterwide     EtcdCluster, EtcdBackup, EtcdRestore
----

==== Troubleshooting

If you don't see etcd Operator using above command or by doing `kubectl get csv -n operators`, make sure that pod belonging to the `CatalogSource` named `operatorhubio-catalog` is running:
[source,sh]
----
$ kubectl get po -n olm | grep operatorhubio-catalog
----

If the state of this pod is `CrashLoopBackOff`, delete it so that Kubernetes will automatically spin up a new pod for the `CatalogSource`:

[source,sh]
----
$ kubectl delete po -n olm <name-of-operatorhubio-catalog-pod>
----

Once the pod for this `CatalogSource` is up, wait a few seconds before trying to find the etcd Operator when you do `odo catalog list services`.

=== Installing the Service Binding Operator

We use the link:https://github.com/redhat-developer/service-binding-operator/[Service Binding Operator] to provide `odo link` feature which links an odo component with an Operator backed service. Thus, to be able to use this feature, it's essential that we install the Operator first.

Service Binding Operator is not yet available via the OLM. The team is link:https://github.com/redhat-developer/service-binding-operator/issues/727[working on making it available] through OLM.

At the moment, to make Service Binding Operator work on Kubernetes, we need to keep a couple of things in mind:

. It needs to be installed by cloning its GitHub repository
. It must be installed in an individual namespace unlike the cluster wide installation we saw for etcd Operator in previous section


Let's setup the Service Binding Operator now.

. First, let's clone its repository on the host system where we're running minikube and checkout the specific tag that is currently supported by `odo link` command:
+
[source,sh]
----
$ git clone https://github.com/redhat-developer/service-binding-operator/
$ cd service-binding-operator
$ git fetch --tags
$ git checkout tags/v0.1.1-364 -b v0.1.1-364
$ cd deploy
----

. Next, install its CRD (link:https://docs.openshift.com/container-platform/latest/operators/understanding/crds/crd-extending-api-with-crds.html[Custom Resource Definition]) and create link:https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/[ServiceAccount], https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole[Role] and link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding[RoleBinding] it requires:
+
[source,sh]
----
$ kubectl create -f crds/apps.openshift.io_servicebindingrequests_crd.yaml
$ kubectl create -f service_account.yaml -f role.yaml -f role_binding.yaml
----

. Now, create a link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/#role-and-clusterrole[ClusterRole] and a link:https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding[ClusterRoleBinding] that are required to allow the Service Binding Operator access resources of API groups `apps.openshift.io` and `apiextensions.k8s.io` at cluster level:
+
[source,sh]
----
$ kubectl create -f - << EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: sbo-cluster-role
rules:
- apiGroups: 
  - apps.openshift.io
  resources: 
  - "*"
  verbs:
  - "*"
- apiGroups:
  - apiextensions.k8s.io
  resources:
  - customresourcedefinitions
  - customresourcedefinitions/status
  verbs:
  - get
  - list
  - patch
  - watch
EOF

$ kubectl create -f - << EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: sbo-cluster-role-binding
subjects:
- kind: ServiceAccount
  name: service-binding-operator
  namespace: default
roleRef:
  kind: ClusterRole
  name: sbo-cluster-role
  apiGroup: rbac.authorization.k8s.io
EOF
----

. Next, we modify the `operator.yaml` file to install the Operator in a specific namespace and use the container image that matches the version of the git commit (`git log -n1 --oneline`) of the repository. Make change as per below `git diff` but make sure to set the value of `namespace` to the namespace where you want to install the Operator:
+
[source,diff]
----
diff --git a/deploy/operator.yaml b/deploy/operator.yaml
index 2cd90ec7..21c4768c 100644
--- a/deploy/operator.yaml
+++ b/deploy/operator.yaml
@@ -4,0 +5 @@ metadata:
+  namespace: default
@@ -19 +20 @@ spec:
-          image: REPLACE_IMAGE
+          image: quay.io/redhat-developer/app-binding-operator:0799ba7
----

. Finally, install the Operator using below command:
+
[source,sh]
----
$ kubectl create -f operator.yaml
----


You should now see a `Deployment` for Service Binding Operator in the namespace where you installed it:
[source,sh]
----
$ kubectl get deploy -n <replace-namespace-value>
----

